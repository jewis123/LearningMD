### [Lua与C++交互方式]
https://www.cnblogs.com/sevenyuan/p/4511808.html



>摘要：
>
>`lua`和`C++`交互的方式主要依靠`Lua`栈：它是在随`Lua_State`创建的。存入栈的数据类型包括：数值、字符串、指针、表、闭包等，但是这些不同类型的数据结构最终会被统一成`TValue`这种数据结构保存。
>
>- `c++`调用`Lua`：
>
>`lua`和`c++`各自管理自己产生的值。`Lua`的产生的值如果需要被`C++`访问，会放到`Lua`栈上，让`C++`通过`API`去操作。 
>
>**c value –> lua value的流向, 不管是想把一个简单的5放入lua的世界, 还是创建一个table, 都会导致**
>
>​         **1. 栈顶新分配元素  2. 绑定或赋值**
>
>​        **还是为了重复一句话, 一个c value入栈就是进入了lua的世界, lua会生成一个对应的结构并管理起来, 从此就不再依赖这个c value**
>
>函数调用流程是先将函数入栈，参数入栈，然后用`lua_pcall`调用函数，此时栈顶为参数，栈底为函数，所以栈过程大致会是：参数出栈->保存参数->参数出栈->保存参数->函数出栈->调用函数->返回结果入栈。
>
>- `Lua`调用自定义`C++`函数
>
>需要在`lua.h`中添加函数规范定义，然后在`lua.c`中实现函数，然后再`C++`层调用`lua_register`将C++中自定义的函数注册进`Lua`解释器中。



### 调用细节

- 根据Lua和C++交互机制，调用开始时，Lua会把从左到右的Lua参数依次压入栈；调用结束时，C++会把返回值依次压入栈中，同时return返回值个数，lua会根据return的返回值个数，依次去栈顶取出返回值。

- 在Lua中，如果调用了一个元表中不存在的`Key`时，就会触发元表的`__Index`元方法。触发index元方法时，传入index元方法的参数有两个：被索引表和被索引的key。可以通过指定`__Index`到自定义方法，来实现创建`Key`的一系列操作。例如，在`Unlua`中，就会去执行注册逻辑，通过反射，将UE的类型、方法、字段等一系列内容注册进`G`表。

  ![](img\index元方法.jpg)

- 

