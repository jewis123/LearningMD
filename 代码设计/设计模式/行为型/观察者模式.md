#### 介绍
定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。

**结构**

![结构图](D:\Pattern\DesignPattern\DesignPattern\BehaviorPattern\Observer\结构图.png)

#### 优点
    ● 观察者和被观察者之间是抽象耦合
　　如此设计， 则不管是增加观察者还是被观察者都非常容易扩展。

    ● 建立一套触发机制
　　根据单一职责原则，每个类的职责是单一的，那么怎么把各个单一的职责串联成真实世界的复杂的逻辑关系呢？ 比如， 我们去打猎， 打死了一只母鹿， 母鹿有三个幼崽，因失去了母鹿而饿死，尸体又被两只秃鹰争抢，因分配不均，秃鹰开始斗殴，然后羸弱的秃鹰死掉，生存下来的秃鹰，则因此扩大了地盘……这就是一个触发机制，形成了一个触发链。观察者模式可以完美地实现这里的链条形式。

#### 缺点
观察者模式需要考虑一下开发效率和运行效率问题， 一个被观察者，多个观察者，开发和调试就会比较复杂，如果通知默认是顺序执行， 一个观察者卡壳，会影响整体的执行效率。 在这种情况下， 一般考虑采用异步的方式。
多级触发时的效率更是让人担忧，大家在设计时注意考虑。

#### 使用场景
　　● 关联行为，当一个对象的改变需要同时改变其他对象的时候，而且它不知道具体有多少对象有待改变时。 需要注意的是， 关联行为是可拆分的， 而不是“组合”关系。

　　● 事件多级触发。

　　● 跨系统的消息交换， 如消息队列的处理机制。 

#### 注意事项
    ● 广播链的问题
一个观察者可以有双重身份，既是观察者，也是被观察者， 这没什么问题呀，但是链一旦建立， 这个逻辑就比较复杂， 可维护性非常差， 根据经验建议，在一个观察者模式中**最多出现一个对象既是观察者也是被观察者**， 也就是说消息最多转发一次（ 传递两次） ， 这还是比较好控制的。

　　● 异步处理问题
　　被观察者发生动作了，观察者要做出回应，如果观察者比较多，而且处理时间比较长怎么办？那就用异步呗，异步处理就要考虑线程安全和队列的问题，这个大家有时间看看Message Queue，就会有更深的了解。 


#### 观察者模式 VS 责任链模式
它和责任链模式的最大区别就是：观察者广播链在传播的过程中消息是随时更改的， 它是由相邻的两个节点协商的消息结构； 而责任链模式在消息传递过程中基本上保持消息不可变，如果要改变，也只是在原有的消息上进行修正。
